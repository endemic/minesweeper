<!DOCTYPE html>
<html>

<head>
  <title>MinÃ«sweeper</title>
  <meta charset="utf8">
  <link rel="icon" href="images/flag.png">

  <script type="module">
    const EMPTY = 0;
    const UNKNOWN = 9;
    const FLAG = 10;
    const MINE = 11;

    class Game {
      constructor() {
        // our grid contains simple integers to represent game objects;
        // this map translates the numbers to a string, that can then be used as
        // human-readable reference or CSS class (for display purposes)
        this.valueMap = {
          0: 'empty',
          1: 'one',
          2: 'two',
          3: 'three',
          4: 'four',
          5: 'five',
          6: 'six',
          7: 'seven',
          8: 'eight',
          9: 'unknown',
          10: 'flag',
          11: 'mine'
        };

        this.rowCount = 10;
        this.columnCount = 10;

        // Create array backing the visual component of the game
        // Grid will be reflected in DOM/CSS when `this.render()` is called
        this.displayGrid = Array(this.rowCount * this.columnCount).fill(null);

        // set up DOM references
        let boardRef = document.querySelector('section.board');
        this.gridRef = [];

        this.displayGrid.forEach((value, index) => {
          let node = document.createElement('div');
          node.dataset.index = index;

          // Add to DOM
          boardRef.appendChild(node);

          // Add to an easy-to-access array
          this.gridRef.push(node);
        });

        let nextDisplayGrid = [...this.displayGrid];

        // set initial background
        nextDisplayGrid.fill(9);

        // do initial draw
        this.render(nextDisplayGrid);

        // bind context variable to the current Game() object
        // for each of these global handlers/interval
        window.addEventListener('touchend', this.onClick.bind(this));
        window.addEventListener('click', this.onClick.bind(this));

        // intercept right clicks within the game board, but not the whole window
        boardRef.addEventListener('contextmenu', this.onRightClick.bind(this));

        // Set up grid that persists state of mines/clues
        this.mineGrid = Array(this.rowCount * this.columnCount).fill(0);

        // TODO: hardcoded to easy mode
        let mineCount = 10;
        while (mineCount > 1) {
          let randomIndex = Math.floor(Math.random() * this.columnCount * this.rowCount);

          if (this.mineGrid[randomIndex] === 0) {
            this.mineGrid[randomIndex] = 11;
            mineCount -= 1;
          }
        }

        // Set up hints by checking the 8 adjacent spaces
        for (let i = 0; i < this.mineGrid.length; i += 1) {
          // don't overwrite mines with hints
          if (this.mineGrid[i] === 11) {
            continue;
          }

          // Find the number of mines contained in neighboring cells
          let hintValue = this.getNeighbors(i).filter(i => this.mineGrid[i] === 11).length;

          this.mineGrid[i] = hintValue;
        }

        // TODO: extract this to a generic "state dump" method
        for (let row = 0; row < this.rowCount; row += 1) {
          console.log(this.mineGrid.slice(row * this.columnCount, row * this.columnCount + this.columnCount))
        }

        // DEBUG -- immediately display mine state
        // this.render([...this.mineGrid]);

        // run any logic tests
        this.test();
      }

      getNeighbors(index) {
        const calcRow = i => Math.floor(i / this.columnCount);

        // since we're using a 1D array, it's possible that a naive neighbor calculation
        // would wrap to the other side of the board (e.g. a cell on the left-most column
        // would have a "neighbor" in the right-most column). These helper functions
        // ensure that wrapping doesn't occur. This could also be solved by using a 2D
        // array for the board grid instead.
        const inPrevRow = i => calcRow(i) === calcRow(index - this.columnCount);
        const inSameRow = i => calcRow(i) === calcRow(index);
        const inNextRow = i => calcRow(i) === calcRow(index + this.columnCount);

        // ensure no negative or greater than array length indices
        const withinBounds = i => i >= 0 && i < this.rowCount * this.columnCount;

        let prevRow = [
          index - this.columnCount - 1,
          index - this.columnCount,
          index - this.columnCount + 1
        ].filter(withinBounds).filter(inPrevRow);

        let sameRow = [
          index - 1,
          index + 1
        ].filter(withinBounds).filter(inSameRow);

        let nextRow = [
          index + this.columnCount - 1,
          index + this.columnCount,
          index + this.columnCount + 1
        ].filter(withinBounds).filter(inNextRow);

        return [].concat(prevRow, sameRow, nextRow);
      }

      onTouchEnd(e) {
        // TODO: fill this out
        // store local ref to last touch
        const endTouch = e.changedTouches[0];

        let xDiff = endTouch.clientX - this.currentTouch.clientX;
        let yDiff = endTouch.clientY - this.currentTouch.clientY;
      }

      onClick(event) {
        const clickedIndex = parseInt(event.target.dataset.index, 10);

        // don't do anything if cell contents are revealed
        if (this.displayGrid[clickedIndex] !== UNKNOWN) {
          return;
        }

        let nextDisplayGrid = [...this.displayGrid]; // shallow clone

        if (this.mineGrid[clickedIndex] === MINE) {
          window.alert('u lose, you clicked on a mine!')

          // show all mines in the level
          this.mineGrid.forEach((value, index) => {
            if (value === MINE) {
              nextDisplayGrid[index] = value;
            }
          });
        } else {
          // reveal whatever "safe" tile you clicked
          // nextDisplayGrid[clickedIndex] = this.mineGrid[clickedIndex];

          // TODO: reveal all contiguous empty tiles
          // TODO: this mutates `nextDisplayGrid`, as it is passed by reference
          this.reveal(clickedIndex, nextDisplayGrid);
        }

        // update display
        this.render(nextDisplayGrid);
      }

      onRightClick(event) {
        event.preventDefault();

        const clickedIndex = parseInt(event.target.dataset.index, 10);

        // don't do anything if cell contents are revealed
        // TODO: extract this logic to allow flagged spaces to be clicked
        if (this.displayGrid[clickedIndex] !== UNKNOWN &&
          this.displayGrid[clickedIndex] !== FLAG) {
          return;
        }

        let nextDisplayGrid = [...this.displayGrid]; // shallow clone

        // toggle flag in this cell
        if (this.displayGrid[clickedIndex] === FLAG) {
          nextDisplayGrid[clickedIndex] = UNKNOWN;
        } else {
          nextDisplayGrid[clickedIndex] = FLAG;
        }

        // update display
        this.render(nextDisplayGrid);
      }

      // recursive function that will reveal as much of the game board
      // as possible if player clicks on an empty cell
      reveal(index, nextDisplayGrid) {
        // if this space has already been revealed, then stop
        if (nextDisplayGrid[index] !== UNKNOWN) {
          return;
        }

        // reveal the space
        nextDisplayGrid[index] = this.mineGrid[index];

        // if this space is a hint, then stop
        if (nextDisplayGrid[index] !== EMPTY) {
          return;
        }

        // otherwise, since the cell is empty, we check
        // all 8 neighbors for more empty cells
        this.getNeighbors(index).forEach(neighbor => {
          this.reveal(neighbor, nextDisplayGrid);
        });
      }

      render(nextDisplayGrid) {
        // get diff between current state/next state
        let diffIndices = this.displayGrid.reduce((accumulator, currentValue, index) => {
          let nextValue = nextDisplayGrid[index]
          if (nextValue !== currentValue) {
            accumulator.push(index);
          }
          return accumulator;
        }, []);

        // update DOM references
        diffIndices.forEach(index => this.gridRef[index].classList = this.valueMap[nextDisplayGrid[index]]);

        // set the next state as current state
        this.displayGrid = nextDisplayGrid;
      }

      test() {
        const previousValues = [this.columnCount, this.rowCount];
        this.columnCount = 10;
        this.rowCount = 10;

        console.assert(this.getNeighbors(0).join() === '1,10,11', `getNeighbors(0) = ${this.getNeighbors(0)}`);
        console.assert(this.getNeighbors(9).join() === '8,18,19', `getNeighbors(9) = ${this.getNeighbors(9)}`);
        console.assert(this.getNeighbors(99).join() === '88,89,98', `getNeighbors(99) = ${this.getNeighbors(99)}`);

        [this.columnCount, this.rowCount] = previousValues;
      }
    };

    new Game()
  </script>

  <link rel="stylesheet" href="stylesheets/main.css">
</head>

<body>
  <div class="game">
    <section class="board"></section>
    <section class="scoreboard"></section>
  </div>
</body>

</html>
