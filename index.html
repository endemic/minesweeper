<!DOCTYPE html>
<html>

<head>
  <title>MinÃ«sweeper</title>
  <script type="module">
    class Game {
      constructor() {
        // our grid contains simple integers to represent game objects;
        // this map translates the numbers to a string, that can then be used as
        // human-readable reference or CSS class (for display purposes)
        this.valueMap = {
          0: 'empty',
          1: 'one',
          2: 'two',
          3: 'three',
          4: 'four',
          5: 'five',
          6: 'six',
          7: 'seven',
          8: 'eight',
          9: 'unknown',
          10: 'flag',
          11: 'mine'
        };

        this.rowCount = 10;
        this.columnCount = 10;

        // set initial board state as empty
        this.state = Array(this.rowCount * this.columnCount).fill(null);

        // set up DOM references
        let boardRef = document.querySelector('section.board');
        this.gridRef = [];

        this.state.forEach((value, index) => {
          let node = document.createElement('div');
          node.dataset.index = index;

          // Add to DOM
          boardRef.appendChild(node);

          // Add to an easy-to-access variable
          this.gridRef.push(node);
        });

        let nextState = [...this.state];

        // set initial background
        nextState.fill(9);

        // do initial draw
        this.render(nextState);

        // bind context variable to the current Game() object
        // for each of these global handlers/interval
        window.addEventListener('touchend', this.onClick.bind(this));
        window.addEventListener('click', this.onClick.bind(this));

        // set up actual mines
        // TODO: hardcoded on easy mode
        this.mineIndexes = [];
        while (this.mineIndexes.length < 10) {
          let randomIndex = Math.floor(Math.random() * this.columnCount * this.rowCount);

          if (this.mineIndexes.indexOf(randomIndex) === -1) {
            this.mineIndexes.push(randomIndex);
          }
        }
      }

      onTouchEnd(e) {
        // TODO: fill this out
        // store local ref to last touch
        const endTouch = e.changedTouches[0];

        let xDiff = endTouch.clientX - this.currentTouch.clientX;
        let yDiff = endTouch.clientY - this.currentTouch.clientY;
      }

      onClick(event) {
        const clickedIndex = parseInt(event.target.dataset.index, 10);

        if (this.mineIndexes.indexOf(clickedIndex) !== -1) {
          console.log('u lose, you clicked on a mine!')

          // show all mines in the level
          let nextState = [...this.state]; // shallow clone

          this.mineIndexes.forEach(i => {
            nextState[i] = 11; // mine
          });

          // update display
          this.render(nextState);
        }
      }

      update() {
        let nextState = [...this.state]; // shallow clone

        // update display
        this.render(nextState);
      }

      render(nextState) {
        // get diff between current state/next state
        let diffIndices = this.state.reduce((accumulator, currentValue, index) => {
          let nextValue = nextState[index]
          if (nextValue !== currentValue) {
            accumulator.push(index);
          }
          return accumulator;
        }, []);

        // update DOM references
        diffIndices.forEach(index => this.gridRef[index].classList = this.valueMap[nextState[index]]);

        // set the next state as current state
        this.state = nextState;
      }
    };

    new Game()
  </script>

  <link rel="stylesheet" href="css/main.css">
</head>

<body>
  <div class="game">
    <section class="board"></section>
    <section class="scoreboard"></section>
  </div>
</body>

</html>
