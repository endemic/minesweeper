<!DOCTYPE html>
<html>

<head>
  <title>MinÃ«sweeper</title>
  <meta charset="utf8">

  <script type="module">
    class Game {
      constructor() {
        // our grid contains simple integers to represent game objects;
        // this map translates the numbers to a string, that can then be used as
        // human-readable reference or CSS class (for display purposes)
        this.valueMap = {
          0: 'empty',
          1: 'one',
          2: 'two',
          3: 'three',
          4: 'four',
          5: 'five',
          6: 'six',
          7: 'seven',
          8: 'eight',
          9: 'unknown',
          10: 'flag',
          11: 'mine'
        };

        this.rowCount = 10;
        this.columnCount = 10;

        // Create array backing the visual component of the game
        // Grid will be reflected in DOM/CSS when `this.render()` is called
        this.displayGrid = Array(this.rowCount * this.columnCount).fill(null);

        // set up DOM references
        let boardRef = document.querySelector('section.board');
        this.gridRef = [];

        this.displayGrid.forEach((value, index) => {
          let node = document.createElement('div');
          node.dataset.index = index;

          // Add to DOM
          boardRef.appendChild(node);

          // Add to an easy-to-access array
          this.gridRef.push(node);
        });

        let nextDisplayGrid = [...this.displayGrid];

        // set initial background
        nextDisplayGrid.fill(9);

        // do initial draw
        this.render(nextDisplayGrid);

        // bind context variable to the current Game() object
        // for each of these global handlers/interval
        window.addEventListener('touchend', this.onClick.bind(this));
        window.addEventListener('click', this.onClick.bind(this));

        // Set up grid that persists state of mines/clues
        this.mineGrid = Array(this.rowCount * this.columnCount).fill(0);

        // TODO: hardcoded to easy mode
        let mineCount = 10;
        while (mineCount > 1) {
          let randomIndex = Math.floor(Math.random() * this.columnCount * this.rowCount);

          if (this.mineGrid[randomIndex] === 0) {
            this.mineGrid[randomIndex] = 11;
            mineCount -= 1;
          }
        }

        // Set up clues by checking the 8 adjacent spaces
        for (let i = 0; i < this.mineGrid.length; i += 1) {
          if (this.mineGrid[i] === 11) {
            continue;
          }

          let hintValue = this.getNeighbors(i).reduce((accumulator, index) => {
            if (this.mineGrid[index] === 11) {
              accumulator += 1;
            }
            return accumulator;
          }, 0);

          this.mineGrid[i] = hintValue;
        }

        // TODO: extract this to a generic "state dump" method
        for (let row = 0; row < this.rowCount; row += 1) {
          console.log(this.mineGrid.slice(row * this.columnCount, row * this.columnCount + this.columnCount))
        }

        // DEBUG -- immediately display mine state
        this.render([...this.mineGrid]);
      }

      getNeighbors(index) {
        return [
          index - this.columnCount - 1,
          index - this.columnCount,
          index - this.columnCount + 1,
          index - 1,
          index + 1,
          index + this.columnCount - 1,
          index + this.columnCount,
          index + this.columnCount + 1
        ];
      }

      onTouchEnd(e) {
        // TODO: fill this out
        // store local ref to last touch
        const endTouch = e.changedTouches[0];

        let xDiff = endTouch.clientX - this.currentTouch.clientX;
        let yDiff = endTouch.clientY - this.currentTouch.clientY;
      }

      onClick(event) {
        const clickedIndex = parseInt(event.target.dataset.index, 10);

        if (this.mineIndexes.indexOf(clickedIndex) !== -1) {
          console.log('u lose, you clicked on a mine!')

          // show all mines in the level
          let nextState = [...this.displayGrid]; // shallow clone

          this.mineIndexes.forEach(i => {
            nextState[i] = 11; // mine
          });

          // update display
          this.render(nextState);
        }
      }

      update() {
        let nextState = [...this.displayGrid]; // shallow clone

        // update display
        this.render(nextState);
      }

      render(nextDisplayGrid) {
        // get diff between current state/next state
        let diffIndices = this.displayGrid.reduce((accumulator, currentValue, index) => {
          let nextValue = nextDisplayGrid[index]
          if (nextValue !== currentValue) {
            accumulator.push(index);
          }
          return accumulator;
        }, []);

        // update DOM references
        diffIndices.forEach(index => this.gridRef[index].classList = this.valueMap[nextDisplayGrid[index]]);

        // set the next state as current state
        this.displayGrid = nextDisplayGrid;
      }
    };

    new Game()
  </script>

  <link rel="stylesheet" href="stylesheets/main.css">
</head>

<body>
  <div class="game">
    <section class="board"></section>
    <section class="scoreboard"></section>
  </div>
</body>

</html>
